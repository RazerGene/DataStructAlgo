package com.razergene.datastructalgo.hash;

public class Hash
{
	/**
	 * 散列表是算法在时间和空间上作出权衡的经典例子。
	 * 如果没有内存限制，我们可以直接将键作为（可能是一个超大的）数组的索引，那么所有查找操作只需要访问内存一次
	 * 即可完成。但这种情况不会经常出现，因此当键很多时需要的内存太大。
	 * 另一方面，如果没有时间限制，我们可以使用无序数组并进行顺序查找，这样就只需要很少的内存。
	 * 而散列表则使用了适度的空间和时间并在这两个极端之间找到了一种平衡。
	 */
	
	
	/**
	 * Hash算法：哈希函数的key和结果f(key)都是int整数，代表着=两边是两个数组，存储的是map<k,v>类型，哈希函数操作的是其index。
	 * 拿key对应的值如String，哈希函数查找对应的File对象，例如key=5的String是“am”，对应的
	 * 1.直接定址法：f(key) = key;
	 * 2.除法散列法：f(key) = key % m; m要小于key长度的素数，否则这个方法没有意义
	 * 3.乘法散列法：f(key) = floor(m * (key * 0.618 % 1));
	 */
	
	
	
	
	/**
	 * 解决冲突
	 * 1.链接法：将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。
	 * 查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。
	 * 
	 * 2.开放定址法：依靠数组中的空位解决碰撞冲突
	 * (1)线性探测法：当碰撞发生时，我们直接检查散列表中的下一个位置（将索引值加1），
	 * 如果不同则继续查找，直到找到该键或遇到一个空元素。
	 */
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
}
